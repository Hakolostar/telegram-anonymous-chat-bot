// Telegram Anonymous Chat Bot
// Built with Telegraf v4 and MongoDB/Redis
require('dotenv').config();

const { Telegraf, Markup, session, Scenes, Stage } = require('telegraf');
const { MongoClient } = require('mongodb');
const redis = require('redis');
const Joi = require('joi');
const moment = require('moment');
const Filter = require('bad-words');

// Initialize filter for inappropriate content
const filter = new Filter();

// Bot configuration
const BOT_TOKEN = process.env.BOT_TOKEN;
const MONGO_URI = process.env.MONGO_URI;
const REDIS_URL = process.env.REDIS_URL;
const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID;

if (!BOT_TOKEN) {
    console.error('âŒ BOT_TOKEN is required in environment variables');
    process.exit(1);
}

// Initialize bot
const bot = new Telegraf(BOT_TOKEN);

// Database clients
let db = null;
let redisClient = null;

// In-memory fallback for development
let memoryUsers = new Map();
let memoryQueue = new Map();
let memoryMatches = new Map();

// Constants
const INTERESTS = [
    'ğŸ’» Technology', 'ğŸµ Music', 'âœˆï¸ Travel', 'ğŸ›ï¸ Politics', 
    'ğŸ¬ Movies', 'ğŸ® Gaming', 'ğŸ“š Books', 'ğŸƒ Sports',
    'ğŸ³ Cooking', 'ğŸ¨ Art', 'ğŸ“¸ Photography', 'ğŸ§˜ Meditation',
    'ğŸŒ± Nature', 'ğŸ’¼ Business', 'ğŸ”¬ Science', 'ğŸ­ Theater',
    'ğŸš— Cars', 'ğŸ‘— Fashion', 'ğŸ  DIY', 'ğŸ• Pets'
];

const EDUCATION_LEVELS = [
    'High School', 'Bachelor', 'Master', 'PhD', 'Other'
];

const LANGUAGES = [
    'English', 'Spanish', 'French', 'Arabic', 'Amharic', 
    'Chinese', 'German', 'Italian', 'Portuguese', 'Russian', 'Other'
];

const GENDERS = ['Male', 'Female', 'Other'];
const GENDER_PREFERENCES = ['Any', 'Male only', 'Female only'];

// Validation schemas
const profileSchema = Joi.object({
    userId: Joi.number().required(),
    username: Joi.string().allow(''),
    firstName: Joi.string().required(),
    age: Joi.number().min(13).max(100).required(),
    gender: Joi.string().valid(...GENDERS).required(),
    education: Joi.string().valid(...EDUCATION_LEVELS).required(),
    interests: Joi.array().items(Joi.string()).min(1).max(10).required(),
    preferredGender: Joi.string().valid(...GENDER_PREFERENCES).required(),
    language: Joi.string().valid(...LANGUAGES).required(),
    createdAt: Joi.date().default(Date.now),
    lastActive: Joi.date().default(Date.now),
    isActive: Joi.boolean().default(true),
    isBanned: Joi.boolean().default(false)
});

// Initialize filter for inappropriate content
const filter = new Filter();

// Bot configuration
const BOT_TOKEN = process.env.BOT_TOKEN;
const MONGO_URI = process.env.MONGO_URI;
const REDIS_URL = process.env.REDIS_URL;
const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID;

if (!BOT_TOKEN) {
    console.error('âŒ BOT_TOKEN is required in environment variables');
    process.exit(1);
}

// Initialize bot
const bot = new Telegraf(BOT_TOKEN);

// Database clients
let db = null;
let redisClient = null;

// In-memory fallback for development
let memoryUsers = new Map();
let memoryQueue = new Map();
let memoryMatches = new Map();

// Constants
const INTERESTS = [
    'ğŸ’» Technology', 'ğŸµ Music', 'âœˆï¸ Travel', 'ğŸ›ï¸ Politics', 
    'ğŸ¬ Movies', 'ğŸ® Gaming', 'ğŸ“š Books', 'ğŸƒ Sports',
    'ğŸ³ Cooking', 'ğŸ¨ Art', 'ğŸ“¸ Photography', 'ğŸ§˜ Meditation',
    'ğŸŒ± Nature', 'ğŸ’¼ Business', 'ğŸ”¬ Science', 'ğŸ­ Theater',
    'ğŸš— Cars', 'ğŸ‘— Fashion', 'ğŸ  DIY', 'ğŸ• Pets'
];

const EDUCATION_LEVELS = [
    'High School', 'Bachelor', 'Master', 'PhD', 'Other'
];

const LANGUAGES = [
    'English', 'Spanish', 'French', 'Arabic', 'Amharic', 
    'Chinese', 'German', 'Italian', 'Portuguese', 'Russian', 'Other'
];

const GENDERS = ['Male', 'Female', 'Other'];
const GENDER_PREFERENCES = ['Any', 'Male only', 'Female only'];

// Validation schemas
const profileSchema = Joi.object({
    userId: Joi.number().required(),
    username: Joi.string().allow(''),
    firstName: Joi.string().required(),
    age: Joi.number().min(13).max(100).required(),
    gender: Joi.string().valid(...GENDERS).required(),
    education: Joi.string().valid(...EDUCATION_LEVELS).required(),
    interests: Joi.array().items(Joi.string()).min(1).max(10).required(),
    preferredGender: Joi.string().valid(...GENDER_PREFERENCES).required(),
    language: Joi.string().valid(...LANGUAGES).required(),
    createdAt: Joi.date().default(Date.now),
    lastActive: Joi.date().default(Date.now),
    isActive: Joi.boolean().default(true),
    isBanned: Joi.boolean().default(false)
});

// Utility function to safely edit messages
async function safeEditMessage(ctx, messageId, text, extra = {}) {
    try {
        if (messageId) {
            await ctx.telegram.editMessageText(ctx.chat.id, messageId, undefined, text, extra);
        } else {
            await ctx.editMessageText(text, extra);
        }
    } catch (error) {
        if (error.description && error.description.includes('message is not modified')) {
            console.log('Message edit skipped - content unchanged');
            return;
        }
        console.error('Error editing message:', error);
        throw error;
    }
}

async function safeEditReplyMarkup(ctx, markup, messageId = null) {
    try {
        if (messageId) {
            await ctx.telegram.editMessageReplyMarkup(ctx.chat.id, messageId, undefined, markup);
        } else {
            await ctx.editMessageReplyMarkup(markup);
        }
    } catch (error) {
        if (error.description && error.description.includes('message is not modified')) {
            console.log('Message reply markup edit skipped - content unchanged');
            return;
        }
        console.error('Error editing reply markup:', error);
        throw error;
    }
}

// Database initialization
async function initDatabase() {
    try {
        if (MONGO_URI) {
            console.log('ğŸ”Œ Connecting to MongoDB...');
            const client = new MongoClient(MONGO_URI);
            await client.connect();
            db = client.db('anonymous_chat_bot');
            
            // Create indexes
            await db.collection('users').createIndex({ userId: 1 }, { unique: true });
            await db.collection('matches').createIndex({ participants: 1 });
            await db.collection('queue').createIndex({ userId: 1 }, { unique: true });
            
            console.log('âœ… MongoDB connected successfully');
        } else if (REDIS_URL) {
            console.log('ğŸ”Œ Connecting to Redis...');
            redisClient = redis.createClient({ url: REDIS_URL });
            await redisClient.connect();
            console.log('âœ… Redis connected successfully');
        } else {
            console.log('âš ï¸  Using in-memory storage (not recommended for production)');
        }
    } catch (error) {
        console.error('âŒ Database connection failed:', error.message);
        console.log('ğŸ“ Falling back to in-memory storage');
    }
}

// Database operations
class DatabaseOperations {
    // User operations
    static async saveUser(userProfile) {
        try {
            const { error, value } = profileSchema.validate(userProfile);
            if (error) throw new Error(`Validation error: ${error.details[0].message}`);

            if (db) {
                await db.collection('users').replaceOne(
                    { userId: value.userId },
                    value,
                    { upsert: true }
                );
            } else if (redisClient) {
                await redisClient.set(`user:${value.userId}`, JSON.stringify(value));
            } else {
                memoryUsers.set(value.userId, value);
            }
            
            return value;
        } catch (error) {
            console.error('Error saving user:', error);
            throw error;
        }
    }

    static async getUser(userId) {
        try {
            if (db) {
                return await db.collection('users').findOne({ userId });
            } else if (redisClient) {
                const userData = await redisClient.get(`user:${userId}`);
                return userData ? JSON.parse(userData) : null;
            } else {
                return memoryUsers.get(userId) || null;
            }
        } catch (error) {
            console.error('Error getting user:', error);
            return null;
        }
    }

    static async updateUserActivity(userId) {
        try {
            const updateData = { lastActive: new Date() };
            
            if (db) {
                await db.collection('users').updateOne(
                    { userId },
                    { $set: updateData }
                );
            } else if (redisClient) {
                const userData = await this.getUser(userId);
                if (userData) {
                    await redisClient.set(`user:${userId}`, JSON.stringify({
                        ...userData,
                        ...updateData
                    }));
                }
            } else {
                const userData = memoryUsers.get(userId);
                if (userData) {
                    memoryUsers.set(userId, { ...userData, ...updateData });
                }
            }
        } catch (error) {
            console.error('Error updating user activity:', error);
        }
    }

    // Queue operations
    static async addToQueue(userId, preferences = {}) {
        try {
            const queueEntry = {
                userId,
                preferences,
                timestamp: new Date()
            };

            if (db) {
                await db.collection('queue').replaceOne(
                    { userId },
                    queueEntry,
                    { upsert: true }
                );
            } else if (redisClient) {
                await redisClient.set(`queue:${userId}`, JSON.stringify(queueEntry));
            } else {
                memoryQueue.set(userId, queueEntry);
            }

            // Notify existing queue members about new user joining
            await this.notifyQueueAboutNewUser(userId);
        } catch (error) {
            console.error('Error adding to queue:', error);
        }
    }

    static async notifyQueueAboutNewUser(newUserId) {
        try {
            const newUser = await this.getUser(newUserId);
            if (!newUser) return;

            const queueEntries = await this.getQueueEntries();
            
            // Check if any existing queue members are compatible with the new user
            for (const entry of queueEntries) {
                if (entry.userId === newUserId) continue;
                
                const queuedUser = await this.getUser(entry.userId);
                if (!queuedUser || queuedUser.isBanned) continue;

                // Check compatibility
                const score = MatchingService?.calculateCompatibilityScore(queuedUser, newUser);
                if (score && score > 5) { // High compatibility threshold
                    try {
                        // Notify the queued user about potential match
                        await bot.telegram.sendMessage(entry.userId, 
                            'ğŸ”” **Someone compatible just joined!**\n\n' +
                            'âœ¨ High compatibility detected\n' +
                            'ğŸ” Use /find to connect instantly!', {
                            parse_mode: 'Markdown',
                            ...Markup.inlineKeyboard([
                                [Markup.button.callback('ğŸ” Find Match Now', 'find_match')]
                            ])
                        });
                    } catch (error) {
                        // User might have blocked the bot or deleted account
                        console.log(`Could not notify user ${entry.userId}:`, error.message);
                    }
                }
            }
        } catch (error) {
            console.error('Error notifying queue about new user:', error);
        }
    }

    static async removeFromQueue(userId) {
        try {
            if (db) {
                await db.collection('queue').deleteOne({ userId });
            } else if (redisClient) {
                await redisClient.del(`queue:${userId}`);
            } else {
                memoryQueue.delete(userId);
            }
        } catch (error) {
            console.error('Error removing from queue:', error);
        }
    }

    static async getQueueEntries() {
        try {
            if (db) {
                return await db.collection('queue').find({}).toArray();
            } else if (redisClient) {
                const keys = await redisClient.keys('queue:*');
                const entries = [];
                for (const key of keys) {
                    const data = await redisClient.get(key);
                    if (data) entries.push(JSON.parse(data));
                }
                return entries;
            } else {
                return Array.from(memoryQueue.values());
            }
        } catch (error) {
            console.error('Error getting queue entries:', error);
            return [];
        }
    }

    // Match operations
    static async createMatch(user1Id, user2Id) {
        try {
            const matchId = `${Math.min(user1Id, user2Id)}_${Math.max(user1Id, user2Id)}`;
            const match = {
                id: matchId,
                participants: [user1Id, user2Id],
                createdAt: new Date(),
                isActive: true
            };

            if (db) {
                await db.collection('matches').insertOne(match);
            } else if (redisClient) {
                await redisClient.set(`match:${matchId}`, JSON.stringify(match));
                await redisClient.set(`user_match:${user1Id}`, matchId);
                await redisClient.set(`user_match:${user2Id}`, matchId);
            } else {
                memoryMatches.set(matchId, match);
                memoryMatches.set(`user_${user1Id}`, matchId);
                memoryMatches.set(`user_${user2Id}`, matchId);
            }

            return matchId;
        } catch (error) {
            console.error('Error creating match:', error);
            throw error;
        }
    }

    static async getActiveMatch(userId) {
        try {
            if (db) {
                return await db.collection('matches').findOne({
                    participants: userId,
                    isActive: true
                });
            } else if (redisClient) {
                const matchId = await redisClient.get(`user_match:${userId}`);
                if (matchId) {
                    const matchData = await redisClient.get(`match:${matchId}`);
                    return matchData ? JSON.parse(matchData) : null;
                }
                return null;
            } else {
                const matchId = memoryMatches.get(`user_${userId}`);
                return matchId ? memoryMatches.get(matchId) : null;
            }
        } catch (error) {
            console.error('Error getting active match:', error);
            return null;
        }
    }

    static async endMatch(matchId) {
        try {
            if (db) {
                const match = await db.collection('matches').findOne({ id: matchId });
                if (match) {
                    await db.collection('matches').updateOne(
                        { id: matchId },
                        { $set: { isActive: false, endedAt: new Date() } }
                    );
                }
            } else if (redisClient) {
                const matchData = await redisClient.get(`match:${matchId}`);
                if (matchData) {
                    const match = JSON.parse(matchData);
                    await redisClient.set(`match:${matchId}`, JSON.stringify({
                        ...match,
                        isActive: false,
                        endedAt: new Date()
                    }));
                    
                    // Remove user match references
                    for (const userId of match.participants) {
                        await redisClient.del(`user_match:${userId}`);
                    }
                }
            } else {
                const match = memoryMatches.get(matchId);
                if (match) {
                    match.isActive = false;
                    match.endedAt = new Date();
                    
                    // Remove user match references
                    for (const userId of match.participants) {
                        memoryMatches.delete(`user_${userId}`);
                    }
                }
            }
        } catch (error) {
            console.error('Error ending match:', error);
        }
    }
}

// Matching algorithm
class MatchingService {
    static calculateCompatibilityScore(user1, user2) {
        let score = 0;

        // Check mutual gender preferences
        if (!this.checkGenderCompatibility(user1, user2)) {
            return -1; // Incompatible
        }

        // Shared interests (+5 each)
        const sharedInterests = user1.interests.filter(interest => 
            user2.interests.includes(interest)
        );
        score += sharedInterests.length * 5;

        // Age compatibility (+3 if within reasonable range)
        const ageDiff = Math.abs(user1.age - user2.age);
        if (ageDiff <= 5) score += 3;
        else if (ageDiff <= 10) score += 1;

        // Language match (+2)
        if (user1.language === user2.language) score += 2;

        // Education level bonus (+1)
        if (user1.education === user2.education) score += 1;

        return score;
    }

    static checkGenderCompatibility(user1, user2) {
        // Check if user1 wants user2's gender
        const user1WantsUser2 = user1.preferredGender === 'Any' || 
                               user1.preferredGender.replace(' only', '') === user2.gender;

        // Check if user2 wants user1's gender
        const user2WantsUser1 = user2.preferredGender === 'Any' || 
                               user2.preferredGender.replace(' only', '') === user1.gender;

        return user1WantsUser2 && user2WantsUser1;
    }

    static async findBestMatch(currentUser) {
        try {
            const queueEntries = await DatabaseOperations.getQueueEntries();
            let bestMatch = null;
            let bestScore = -1;

            for (const entry of queueEntries) {
                if (entry.userId === currentUser.userId) continue;

                const candidateUser = await DatabaseOperations.getUser(entry.userId);
                if (!candidateUser || candidateUser.isBanned) continue;

                const score = this.calculateCompatibilityScore(currentUser, candidateUser);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = candidateUser;
                }
            }

            return bestScore >= 0 ? bestMatch : null;
        } catch (error) {
            console.error('Error finding match:', error);
            return null;
        }
    }

    // New method: Wait for a match with periodic checking
    static async findMatchWithWait(currentUser, ctx, maxWaitTimeSeconds = 30) {
        const startTime = Date.now();
        const checkInterval = 3000; // Check every 3 seconds
        let lastUpdateTime = 0;
        let attempt = 0;

        // Send initial waiting message
        const waitingMessage = await ctx.reply(
            'ğŸ” **Searching for your perfect match...**\n\n' +
            'â³ Please wait while we find someone compatible\n' +
            'ğŸ¯ Looking for users with similar interests\n' +
            'â­ This may take up to 30 seconds\n\n' +
            '_Searching..._',
            { parse_mode: 'Markdown' }
        );

        return new Promise((resolve) => {
            const searchInterval = setInterval(async () => {
                try {
                    attempt++;
                    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                    
                    // Update progress message every 6 seconds
                    if (elapsedTime - lastUpdateTime >= 6) {
                        lastUpdateTime = elapsedTime;
                        const remainingTime = Math.max(0, maxWaitTimeSeconds - elapsedTime);
                        
                        const progressDots = '.'.repeat((attempt % 3) + 1);
                        const progressMessage = 
                            'ğŸ” **Searching for your perfect match...**\n\n' +
                            `â³ Time elapsed: ${elapsedTime}s\n` +
                            `â° Time remaining: ~${remainingTime}s\n` +
                            `ğŸ¯ Checking compatibility${progressDots}\n\n` +
                            '_Expanding search criteria..._';

                        try {
                            await ctx.telegram.editMessageText(
                                ctx.chat.id,
                                waitingMessage.message_id,
                                undefined,
                                progressMessage,
                                { parse_mode: 'Markdown' }
                            );
                        } catch (editError) {
                            // Ignore edit errors (message might be too old)
                        }
                    }

                    // Try to find a match
                    const match = await this.findBestMatch(currentUser);
                    
                    if (match) {
                        clearInterval(searchInterval);
                        
                        try {
                            await ctx.telegram.editMessageText(
                                ctx.chat.id,
                                waitingMessage.message_id,
                                undefined,
                                'âœ… **Match Found!**\n\nğŸ‰ Connecting you now...',
                                { parse_mode: 'Markdown' }
                            );
                        } catch (editError) {
                            // If edit fails, send new message
                            await ctx.reply('âœ… **Match Found!**\n\nğŸ‰ Connecting you now...', {
                                parse_mode: 'Markdown'
                            });
                        }
                        
                        resolve(match);
                        return;
                    }

                    // Check if time limit exceeded
                    if (elapsedTime >= maxWaitTimeSeconds) {
                        clearInterval(searchInterval);
                        
                        try {
                            await ctx.telegram.editMessageText(
                                ctx.chat.id,
                                waitingMessage.message_id,
                                undefined,
                                'â³ **Search completed**\n\n' +
                                'ğŸ˜” No compatible matches found right now\n' +
                                'ğŸ“ You\'ve been added to the waiting queue\n' +
                                'ğŸ”” We\'ll notify you when someone joins!',
                                { parse_mode: 'Markdown' }
                            );
                        } catch (editError) {
                            await ctx.reply(
                                'â³ **Search completed**\n\n' +
                                'ğŸ˜” No compatible matches found right now\n' +
                                'ğŸ“ You\'ve been added to the waiting queue\n' +
                                'ğŸ”” We\'ll notify you when someone joins!',
                                { parse_mode: 'Markdown' }
                            );
                        }
                        
                        resolve(null);
                        return;
                    }

                } catch (error) {
                    console.error('Error during match search:', error);
                    clearInterval(searchInterval);
                    resolve(null);
                }
            }, checkInterval);

            // Cleanup if something goes wrong
            setTimeout(() => {
                clearInterval(searchInterval);
                resolve(null);
            }, (maxWaitTimeSeconds + 5) * 1000);
        });
    }
}

// Scene for profile setup
const profileSetupScene = new Scenes.BaseScene('PROFILE_SETUP');
profileSetupScene.enter(async (ctx) => {
    ctx.session.profileData = ctx.session.profileData || {};
    await ctx.reply('ğŸ‘‹ Welcome! Let\'s set up your profile.\n\nğŸ‚ Please enter your age (13-100):');
});

profileSetupScene.on('text', async (ctx) => {
    const { profileData } = ctx.session;
    const text = ctx.message.text;

    try {
        if (!profileData.age) {
            const age = parseInt(text);
            if (age >= 13 && age <= 100) {
                profileData.age = age;
                await ctx.reply('ğŸ‘¤ What\'s your gender?', 
                    Markup.inlineKeyboard([
                        [Markup.button.callback('ğŸ‘¨ Male', 'gender_Male')],
                        [Markup.button.callback('ğŸ‘© Female', 'gender_Female')],
                        [Markup.button.callback('âš§ï¸ Other', 'gender_Other')]
                    ])
                );
            } else {
                await ctx.reply('âŒ Please enter a valid age between 13 and 100:');
            }
        } else if (!profileData.language && profileData.gender && profileData.education) {
            // Handle language selection after education
            if (LANGUAGES.includes(text)) {
                profileData.language = text;
                await ctx.reply('ğŸ¯ Great! Now select your interests (choose multiple):', 
                    this.createInterestsKeyboard(profileData.interests || [])
                );
            } else {
                await ctx.reply('âŒ Please select a valid language from the keyboard above.');
            }
        }
    } catch (error) {
        console.error('Profile setup error:', error);
        await ctx.reply('âŒ Something went wrong. Please try again.');
    }
});

profileSetupScene.action(/gender_(.+)/, async (ctx) => {
    const gender = ctx.match[1];
    ctx.session.profileData.gender = gender;
    
    await ctx.editMessageText('ğŸ“ What\'s your education level?', 
        Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ« High School', 'edu_High School')],
            [Markup.button.callback('ğŸ“ Bachelor', 'edu_Bachelor')],
            [Markup.button.callback('ğŸ“š Master', 'edu_Master')],
            [Markup.button.callback('ğŸ”¬ PhD', 'edu_PhD')],
            [Markup.button.callback('ğŸ“– Other', 'edu_Other')]
        ])
    );
});

profileSetupScene.action(/edu_(.+)/, async (ctx) => {
    const education = ctx.match[1];
    ctx.session.profileData.education = education;
    
    await ctx.editMessageText('ğŸŒ What\'s your preferred language?', 
        Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ‡ºğŸ‡¸ English', 'lang_English'), Markup.button.callback('ğŸ‡ªğŸ‡¸ Spanish', 'lang_Spanish')],
            [Markup.button.callback('ğŸ‡«ğŸ‡· French', 'lang_French'), Markup.button.callback('ğŸ‡¸ğŸ‡¦ Arabic', 'lang_Arabic')],
            [Markup.button.callback('ğŸ‡ªğŸ‡¹ Amharic', 'lang_Amharic'), Markup.button.callback('ğŸ‡¨ğŸ‡³ Chinese', 'lang_Chinese')],
            [Markup.button.callback('ğŸ‡©ğŸ‡ª German', 'lang_German'), Markup.button.callback('ğŸ‡®ğŸ‡¹ Italian', 'lang_Italian')],
            [Markup.button.callback('ğŸ‡µğŸ‡¹ Portuguese', 'lang_Portuguese'), Markup.button.callback('ğŸ‡·ğŸ‡º Russian', 'lang_Russian')],
            [Markup.button.callback('ğŸŒ Other', 'lang_Other')]
        ])
    );
});

profileSetupScene.action(/lang_(.+)/, async (ctx) => {
    const language = ctx.match[1];
    ctx.session.profileData.language = language;
    
    await ctx.editMessageText('ğŸ¯ Great! Now select your interests (choose multiple):', 
        createInterestsKeyboard(ctx.session.profileData.interests || [])
    );
});

profileSetupScene.action(/interest_(.+)/, async (ctx) => {
    const interest = ctx.match[1];
    const { profileData } = ctx.session;
    
    if (!profileData.interests) profileData.interests = [];
    
    const originalInterests = [...profileData.interests];
    
    if (profileData.interests.includes(interest)) {
        profileData.interests = profileData.interests.filter(i => i !== interest);
    } else if (profileData.interests.length < 10) {
        profileData.interests.push(interest);
    } else {
        // User has reached maximum interests, just answer the callback
        await ctx.answerCbQuery('You can select up to 10 interests maximum');
        return;
    }
    
    // Only edit the message if interests actually changed
    if (JSON.stringify(originalInterests.sort()) !== JSON.stringify(profileData.interests.sort())) {
        try {
            await ctx.editMessageReplyMarkup(createInterestsKeyboard(profileData.interests).reply_markup);
        } catch (error) {
            if (error.description && error.description.includes('message is not modified')) {
                // Ignore this specific error - message content hasn't changed
                console.log('Message edit skipped - content unchanged');
            } else {
                console.error('Error editing message:', error);
            }
        }
    }
    
    await ctx.answerCbQuery();
});

profileSetupScene.action('interests_done', async (ctx) => {
    const { profileData } = ctx.session;
    
    if (!profileData.interests || profileData.interests.length === 0) {
        await ctx.answerCbQuery('âŒ Please select at least one interest');
        return;
    }
    
    await ctx.editMessageText('ğŸ’• Who would you like to chat with?', 
        Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ‘¥ Anyone', 'pref_Any')],
            [Markup.button.callback('ğŸ‘¨ Male only', 'pref_Male only')],
            [Markup.button.callback('ğŸ‘© Female only', 'pref_Female only')]
        ])
    );
});

profileSetupScene.action(/pref_(.+)/, async (ctx) => {
    const preference = ctx.match[1];
    const { profileData } = ctx.session;
    profileData.preferredGender = preference;
    
    // Save complete profile
    try {
        const completeProfile = {
            userId: ctx.from.id,
            username: ctx.from.username || '',
            firstName: ctx.from.first_name,
            ...profileData
        };
        
        await DatabaseOperations.saveUser(completeProfile);
        
        await ctx.editMessageText(
            'âœ… Profile created successfully!\n\n' +
            'ğŸ” Use /find to start looking for someone to chat with!\n' +
            'ğŸ‘¤ Use /profile to update your information\n' +
            'â“ Use /help for more commands'
        );
        
        ctx.session.profileData = null;
        return ctx.scene.leave();
    } catch (error) {
        console.error('Error saving profile:', error);
        await ctx.reply('âŒ Error saving profile. Please try again.');
    }
});

// Utility function to safely edit messages
async function safeEditMessage(ctx, messageId, text, extra = {}) {
    try {
        if (messageId) {
            await ctx.telegram.editMessageText(ctx.chat.id, messageId, undefined, text, extra);
        } else {
            await ctx.editMessageText(text, extra);
        }
    } catch (error) {
        if (error.description && error.description.includes('message is not modified')) {
            console.log('Message edit skipped - content unchanged');
            return;
        }
        console.error('Error editing message:', error);
        throw error;
    }
}

async function safeEditReplyMarkup(ctx, markup, messageId = null) {
    try {
        if (messageId) {
            await ctx.telegram.editMessageReplyMarkup(ctx.chat.id, messageId, undefined, markup);
        } else {
            await ctx.editMessageReplyMarkup(markup);
        }
    } catch (error) {
        if (error.description && error.description.includes('message is not modified')) {
            console.log('Message reply markup edit skipped - content unchanged');
            return;
        }
        console.error('Error editing reply markup:', error);
        throw error;
    }
}

// Database initialization
async function initDatabase() {
    try {
        if (MONGO_URI) {
            console.log('ğŸ”Œ Connecting to MongoDB...');
            const client = new MongoClient(MONGO_URI);
            await client.connect();
            db = client.db('anonymous_chat_bot');
            
            // Create indexes
            await db.collection('users').createIndex({ userId: 1 }, { unique: true });
            await db.collection('matches').createIndex({ participants: 1 });
            await db.collection('queue').createIndex({ userId: 1 }, { unique: true });
            
            console.log('âœ… MongoDB connected successfully');
        } else if (REDIS_URL) {
            console.log('ğŸ”Œ Connecting to Redis...');
            redisClient = redis.createClient({ url: REDIS_URL });
            await redisClient.connect();
            console.log('âœ… Redis connected successfully');
        } else {
            console.log('âš ï¸  Using in-memory storage (not recommended for production)');
        }
    } catch (error) {
        console.error('âŒ Database connection failed:', error.message);
        console.log('ğŸ“ Falling back to in-memory storage');
    }
}

// Database operations
class DatabaseOperations {
    // User operations
    static async saveUser(userProfile) {
        try {
            const { error, value } = profileSchema.validate(userProfile);
            if (error) throw new Error(`Validation error: ${error.details[0].message}`);

            if (db) {
                await db.collection('users').replaceOne(
                    { userId: value.userId },
                    value,
                    { upsert: true }
                );
            } else if (redisClient) {
                await redisClient.set(`user:${value.userId}`, JSON.stringify(value));
            } else {
                memoryUsers.set(value.userId, value);
            }
            
            return value;
        } catch (error) {
            console.error('Error saving user:', error);
            throw error;
        }
    }

    static async getUser(userId) {
        try {
            if (db) {
                return await db.collection('users').findOne({ userId });
            } else if (redisClient) {
                const userData = await redisClient.get(`user:${userId}`);
                return userData ? JSON.parse(userData) : null;
            } else {
                return memoryUsers.get(userId) || null;
            }
        } catch (error) {
            console.error('Error getting user:', error);
            return null;
        }
    }

    static async updateUserActivity(userId) {
        try {
            const updateData = { lastActive: new Date() };
            
            if (db) {
                await db.collection('users').updateOne(
                    { userId },
                    { $set: updateData }
                );
            } else if (redisClient) {
                const userData = await this.getUser(userId);
                if (userData) {
                    await redisClient.set(`user:${userId}`, JSON.stringify({
                        ...userData,
                        ...updateData
                    }));
                }
            } else {
                const userData = memoryUsers.get(userId);
                if (userData) {
                    memoryUsers.set(userId, { ...userData, ...updateData });
                }
            }
        } catch (error) {
            console.error('Error updating user activity:', error);
        }
    }

    // Queue operations
    static async addToQueue(userId, preferences = {}) {
        try {
            const queueEntry = {
                userId,
                preferences,
                timestamp: new Date()
            };

            if (db) {
                await db.collection('queue').replaceOne(
                    { userId },
                    queueEntry,
                    { upsert: true }
                );
            } else if (redisClient) {
                await redisClient.set(`queue:${userId}`, JSON.stringify(queueEntry));
            } else {
                memoryQueue.set(userId, queueEntry);
            }

            // Notify existing queue members about new user joining
            await this.notifyQueueAboutNewUser(userId);
        } catch (error) {
            console.error('Error adding to queue:', error);
        }
    }

    static async notifyQueueAboutNewUser(newUserId) {
        try {
            const newUser = await this.getUser(newUserId);
            if (!newUser) return;

            const queueEntries = await this.getQueueEntries();
            
            // Check if any existing queue members are compatible with the new user
            for (const entry of queueEntries) {
                if (entry.userId === newUserId) continue;
                
                const queuedUser = await this.getUser(entry.userId);
                if (!queuedUser || queuedUser.isBanned) continue;

                // Check compatibility
                const score = MatchingService?.calculateCompatibilityScore(queuedUser, newUser);
                if (score && score > 5) { // High compatibility threshold
                    try {
                        // Notify the queued user about potential match
                        await bot.telegram.sendMessage(entry.userId, 
                            'ğŸ”” **Someone compatible just joined!**\n\n' +
                            'âœ¨ High compatibility detected\n' +
                            'ğŸ” Use /find to connect instantly!', {
                            parse_mode: 'Markdown',
                            ...Markup.inlineKeyboard([
                                [Markup.button.callback('ğŸ” Find Match Now', 'find_match')]
                            ])
                        });
                    } catch (error) {
                        // User might have blocked the bot or deleted account
                        console.log(`Could not notify user ${entry.userId}:`, error.message);
                    }
                }
            }
        } catch (error) {
            console.error('Error notifying queue about new user:', error);
        }
    }

    static async removeFromQueue(userId) {
        try {
            if (db) {
                await db.collection('queue').deleteOne({ userId });
            } else if (redisClient) {
                await redisClient.del(`queue:${userId}`);
            } else {
                memoryQueue.delete(userId);
            }
        } catch (error) {
            console.error('Error removing from queue:', error);
        }
    }

    static async getQueueEntries() {
        try {
            if (db) {
                return await db.collection('queue').find({}).toArray();
            } else if (redisClient) {
                const keys = await redisClient.keys('queue:*');
                const entries = [];
                for (const key of keys) {
                    const data = await redisClient.get(key);
                    if (data) entries.push(JSON.parse(data));
                }
                return entries;
            } else {
                return Array.from(memoryQueue.values());
            }
        } catch (error) {
            console.error('Error getting queue entries:', error);
            return [];
        }
    }

    // Match operations
    static async createMatch(user1Id, user2Id) {
        try {
            const matchId = `${Math.min(user1Id, user2Id)}_${Math.max(user1Id, user2Id)}`;
            const match = {
                id: matchId,
                participants: [user1Id, user2Id],
                createdAt: new Date(),
                isActive: true
            };

            if (db) {
                await db.collection('matches').insertOne(match);
            } else if (redisClient) {
                await redisClient.set(`match:${matchId}`, JSON.stringify(match));
                await redisClient.set(`user_match:${user1Id}`, matchId);
                await redisClient.set(`user_match:${user2Id}`, matchId);
            } else {
                memoryMatches.set(matchId, match);
                memoryMatches.set(`user_${user1Id}`, matchId);
                memoryMatches.set(`user_${user2Id}`, matchId);
            }

            return matchId;
        } catch (error) {
            console.error('Error creating match:', error);
            throw error;
        }
    }

    static async getActiveMatch(userId) {
        try {
            if (db) {
                return await db.collection('matches').findOne({
                    participants: userId,
                    isActive: true
                });
            } else if (redisClient) {
                const matchId = await redisClient.get(`user_match:${userId}`);
                if (matchId) {
                    const matchData = await redisClient.get(`match:${matchId}`);
                    return matchData ? JSON.parse(matchData) : null;
                }
                return null;
            } else {
                const matchId = memoryMatches.get(`user_${userId}`);
                return matchId ? memoryMatches.get(matchId) : null;
            }
        } catch (error) {
            console.error('Error getting active match:', error);
            return null;
        }
    }

    static async endMatch(matchId) {
        try {
            if (db) {
                const match = await db.collection('matches').findOne({ id: matchId });
                if (match) {
                    await db.collection('matches').updateOne(
                        { id: matchId },
                        { $set: { isActive: false, endedAt: new Date() } }
                    );
                }
            } else if (redisClient) {
                const matchData = await redisClient.get(`match:${matchId}`);
                if (matchData) {
                    const match = JSON.parse(matchData);
                    await redisClient.set(`match:${matchId}`, JSON.stringify({
                        ...match,
                        isActive: false,
                        endedAt: new Date()
                    }));
                    
                    // Remove user match references
                    for (const userId of match.participants) {
                        await redisClient.del(`user_match:${userId}`);
                    }
                }
            } else {
                const match = memoryMatches.get(matchId);
                if (match) {
                    match.isActive = false;
                    match.endedAt = new Date();
                    
                    // Remove user match references
                    for (const userId of match.participants) {
                        memoryMatches.delete(`user_${userId}`);
                    }
                }
            }
        } catch (error) {
            console.error('Error ending match:', error);
        }
    }
}

// Matching algorithm
class MatchingService {
    static calculateCompatibilityScore(user1, user2) {
        let score = 0;

        // Check mutual gender preferences
        if (!this.checkGenderCompatibility(user1, user2)) {
            return -1; // Incompatible
        }

        // Shared interests (+5 each)
        const sharedInterests = user1.interests.filter(interest => 
            user2.interests.includes(interest)
        );
        score += sharedInterests.length * 5;

        // Age compatibility (+3 if within reasonable range)
        const ageDiff = Math.abs(user1.age - user2.age);
        if (ageDiff <= 5) score += 3;
        else if (ageDiff <= 10) score += 1;

        // Language match (+2)
        if (user1.language === user2.language) score += 2;

        // Education level bonus (+1)
        if (user1.education === user2.education) score += 1;

        return score;
    }

    static checkGenderCompatibility(user1, user2) {
        // Check if user1 wants user2's gender
        const user1WantsUser2 = user1.preferredGender === 'Any' || 
                               user1.preferredGender.replace(' only', '') === user2.gender;

        // Check if user2 wants user1's gender
        const user2WantsUser1 = user2.preferredGender === 'Any' || 
                               user2.preferredGender.replace(' only', '') === user1.gender;

        return user1WantsUser2 && user2WantsUser1;
    }

    static async findBestMatch(currentUser) {
        try {
            const queueEntries = await DatabaseOperations.getQueueEntries();
            let bestMatch = null;
            let bestScore = -1;

            for (const entry of queueEntries) {
                if (entry.userId === currentUser.userId) continue;

                const candidateUser = await DatabaseOperations.getUser(entry.userId);
                if (!candidateUser || candidateUser.isBanned) continue;

                const score = this.calculateCompatibilityScore(currentUser, candidateUser);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = candidateUser;
                }
            }

            return bestScore >= 0 ? bestMatch : null;
        } catch (error) {
            console.error('Error finding match:', error);
            return null;
        }
    }

    // New method: Wait for a match with periodic checking
    static async findMatchWithWait(currentUser, ctx, maxWaitTimeSeconds = 30) {
        const startTime = Date.now();
        const checkInterval = 3000; // Check every 3 seconds
        let lastUpdateTime = 0;
        let attempt = 0;

        // Send initial waiting message
        const waitingMessage = await ctx.reply(
            'ğŸ” **Searching for your perfect match...**\n\n' +
            'â³ Please wait while we find someone compatible\n' +
            'ğŸ¯ Looking for users with similar interests\n' +
            'â­ This may take up to 30 seconds\n\n' +
            '_Searching..._',
            { parse_mode: 'Markdown' }
        );

        return new Promise((resolve) => {
            const searchInterval = setInterval(async () => {
                try {
                    attempt++;
                    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                    
                    // Update progress message every 6 seconds
                    if (elapsedTime - lastUpdateTime >= 6) {
                        lastUpdateTime = elapsedTime;
                        const remainingTime = Math.max(0, maxWaitTimeSeconds - elapsedTime);
                        
                        const progressDots = '.'.repeat((attempt % 3) + 1);
                        const progressMessage = 
                            'ğŸ” **Searching for your perfect match...**\n\n' +
                            `â³ Time elapsed: ${elapsedTime}s\n` +
                            `â° Time remaining: ~${remainingTime}s\n` +
                            `ğŸ¯ Checking compatibility${progressDots}\n\n` +
                            '_Expanding search criteria..._';

                        try {
                            await ctx.telegram.editMessageText(
                                ctx.chat.id,
                                waitingMessage.message_id,
                                undefined,
                                progressMessage,
                                { parse_mode: 'Markdown' }
                            );
                        } catch (editError) {
                            // Ignore edit errors (message might be too old)
                        }
                    }

                    // Try to find a match
                    const match = await this.findBestMatch(currentUser);
                    
                    if (match) {
                        clearInterval(searchInterval);
                        
                        try {
                            await ctx.telegram.editMessageText(
                                ctx.chat.id,
                                waitingMessage.message_id,
                                undefined,
                                'âœ… **Match Found!**\n\nğŸ‰ Connecting you now...',
                                { parse_mode: 'Markdown' }
                            );
                        } catch (editError) {
                            // If edit fails, send new message
                            await ctx.reply('âœ… **Match Found!**\n\nğŸ‰ Connecting you now...', {
                                parse_mode: 'Markdown'
                            });
                        }
                        
                        resolve(match);
                        return;
                    }

                    // Check if time limit exceeded
                    if (elapsedTime >= maxWaitTimeSeconds) {
                        clearInterval(searchInterval);
                        
                        try {
                            await ctx.telegram.editMessageText(
                                ctx.chat.id,
                                waitingMessage.message_id,
                                undefined,
                                'â³ **Search completed**\n\n' +
                                'ğŸ˜” No compatible matches found right now\n' +
                                'ğŸ“ You\'ve been added to the waiting queue\n' +
                                'ğŸ”” We\'ll notify you when someone joins!',
                                { parse_mode: 'Markdown' }
                            );
                        } catch (editError) {
                            await ctx.reply(
                                'â³ **Search completed**\n\n' +
                                'ğŸ˜” No compatible matches found right now\n' +
                                'ğŸ“ You\'ve been added to the waiting queue\n' +
                                'ğŸ”” We\'ll notify you when someone joins!',
                                { parse_mode: 'Markdown' }
                            );
                        }
                        
                        resolve(null);
                        return;
                    }

                } catch (error) {
                    console.error('Error during match search:', error);
                    clearInterval(searchInterval);
                    resolve(null);
                }
            }, checkInterval);

            // Cleanup if something goes wrong
            setTimeout(() => {
                clearInterval(searchInterval);
                resolve(null);
            }, (maxWaitTimeSeconds + 5) * 1000);
        });
    }
}

// Scene for profile setup
const profileSetupScene = new Scenes.BaseScene('PROFILE_SETUP');
profileSetupScene.enter(async (ctx) => {
    ctx.session.profileData = ctx.session.profileData || {};
    await ctx.reply('ğŸ‘‹ Welcome! Let\'s set up your profile.\n\nğŸ‚ Please enter your age (13-100):');
});

profileSetupScene.on('text', async (ctx) => {
    const { profileData } = ctx.session;
    const text = ctx.message.text;

    try {
        if (!profileData.age) {
            const age = parseInt(text);
            if (age >= 13 && age <= 100) {
                profileData.age = age;
                await ctx.reply('ğŸ‘¤ What\'s your gender?', 
                    Markup.inlineKeyboard([
                        [Markup.button.callback('ğŸ‘¨ Male', 'gender_Male')],
                        [Markup.button.callback('ğŸ‘© Female', 'gender_Female')],
                        [Markup.button.callback('âš§ï¸ Other', 'gender_Other')]
                    ])
                );
            } else {
                await ctx.reply('âŒ Please enter a valid age between 13 and 100:');
            }
        } else if (!profileData.language && profileData.gender && profileData.education) {
            // Handle language selection after education
            if (LANGUAGES.includes(text)) {
                profileData.language = text;
                await ctx.reply('ğŸ¯ Great! Now select your interests (choose multiple):', 
                    this.createInterestsKeyboard(profileData.interests || [])
                );
            } else {
                await ctx.reply('âŒ Please select a valid language from the keyboard above.');
            }
        }
    } catch (error) {
        console.error('Profile setup error:', error);
        await ctx.reply('âŒ Something went wrong. Please try again.');
    }
});

profileSetupScene.action(/gender_(.+)/, async (ctx) => {
    const gender = ctx.match[1];
    ctx.session.profileData.gender = gender;
    
    await ctx.editMessageText('ğŸ“ What\'s your education level?', 
        Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ« High School', 'edu_High School')],
            [Markup.button.callback('ğŸ“ Bachelor', 'edu_Bachelor')],
            [Markup.button.callback('ğŸ“š Master', 'edu_Master')],
            [Markup.button.callback('ğŸ”¬ PhD', 'edu_PhD')],
            [Markup.button.callback('ğŸ“– Other', 'edu_Other')]
        ])
    );
});

profileSetupScene.action(/edu_(.+)/, async (ctx) => {
    const education = ctx.match[1];
    ctx.session.profileData.education = education;
    
    await ctx.editMessageText('ğŸŒ What\'s your preferred language?', 
        Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ‡ºğŸ‡¸ English', 'lang_English'), Markup.button.callback('ğŸ‡ªğŸ‡¸ Spanish', 'lang_Spanish')],
            [Markup.button.callback('ğŸ‡«ğŸ‡· French', 'lang_French'), Markup.button.callback('ğŸ‡¸ğŸ‡¦ Arabic', 'lang_Arabic')],
            [Markup.button.callback('ğŸ‡ªğŸ‡¹ Amharic', 'lang_Amharic'), Markup.button.callback('ğŸ‡¨ğŸ‡³ Chinese', 'lang_Chinese')],
            [Markup.button.callback('ğŸ‡©ğŸ‡ª German', 'lang_German'), Markup.button.callback('ğŸ‡®ğŸ‡¹ Italian', 'lang_Italian')],
            [Markup.button.callback('ğŸ‡µğŸ‡¹ Portuguese', 'lang_Portuguese'), Markup.button.callback('ğŸ‡·ğŸ‡º Russian', 'lang_Russian')],
            [Markup.button.callback('ğŸŒ Other', 'lang_Other')]
        ])
    );
});

profileSetupScene.action(/lang_(.+)/, async (ctx) => {
    const language = ctx.match[1];
    ctx.session.profileData.language = language;
    
    await ctx.editMessageText('ğŸ¯ Great! Now select your interests (choose multiple):', 
        createInterestsKeyboard(ctx.session.profileData.interests || [])
    );
});

profileSetupScene.action(/interest_(.+)/, async (ctx) => {
    const interest = ctx.match[1];
    const { profileData } = ctx.session;
    
    if (!profileData.interests) profileData.interests = [];
    
    const originalInterests = [...profileData.interests];
    
    if (profileData.interests.includes(interest)) {
        profileData.interests = profileData.interests.filter(i => i !== interest);
    } else if (profileData.interests.length < 10) {
        profileData.interests.push(interest);
    } else {
        // User has reached maximum interests, just answer the callback
        await ctx.answerCbQuery('You can select up to 10 interests maximum');
        return;
    }
    
    // Only edit the message if interests actually changed
    if (JSON.stringify(originalInterests.sort()) !== JSON.stringify(profileData.interests.sort())) {
        try {
            await ctx.editMessageReplyMarkup(createInterestsKeyboard(profileData.interests).reply_markup);
        } catch (error) {
            if (error.description && error.description.includes('message is not modified')) {
                // Ignore this specific error - message content hasn't changed
                console.log('Message edit skipped - content unchanged');
            } else {
                console.error('Error editing message:', error);
            }
        }
    }
    
    await ctx.answerCbQuery();
});

profileSetupScene.action('interests_done', async (ctx) => {
    const { profileData } = ctx.session;
    
    if (!profileData.interests || profileData.interests.length === 0) {
        await ctx.answerCbQuery('âŒ Please select at least one interest');
        return;
    }
    
    await ctx.editMessageText('ğŸ’• Who would you like to chat with?', 
        Markup.inlineKeyboard([
            [Markup.button.callback('ğŸ‘¥ Anyone', 'pref_Any')],
            [Markup.button.callback('ğŸ‘¨ Male only', 'pref_Male only')],
            [Markup.button.callback('ğŸ‘© Female only', 'pref_Female only')]
        ])
    );
});

profileSetupScene.action(/pref_(.+)/, async (ctx) => {
    const preference = ctx.match[1];
    const { profileData } = ctx.session;
    profileData.preferredGender = preference;
    
    // Save complete profile
    try {
        const completeProfile = {
            userId: ctx.from.id,
            username: ctx.from.username || '',
            firstName: ctx.from.first_name,
            ...profileData
        };
        
        await DatabaseOperations.saveUser(completeProfile);
        
        await ctx.editMessageText(
            'âœ… Profile created successfully!\n\n' +
            'ğŸ” Use /find to start looking for someone to chat with!\n' +
            'ğŸ‘¤ Use /profile to update your information\n' +
            'â“ Use /help for more commands'
        );
        
        ctx.session.profileData = null;
        return ctx.scene.leave();
    } catch (error) {
        console.error('Error saving profile:', error);
        await ctx.reply('âŒ Error saving profile. Please try again.');
    }
});

// Helper functions
function createInterestsKeyboard(selectedInterests = []) {
    const keyboard = [];
    const interestsPerRow = 2;
    
    for (let i = 0; i < INTERESTS.length; i += interestsPerRow) {
        const row = [];
        for (let j = i; j < Math.min(i + interestsPerRow, INTERESTS.length); j++) {
            const interest = INTERESTS[j];
            const isSelected = selectedInterests.includes(interest);
            const text = isSelected ? `âœ… ${interest}` : interest;
            row.push(Markup.button.callback(text, `interest_${interest}`));
        }
        keyboard.push(row);
    }
    
    keyboard.push([Markup.button.callback('âœ… Done', 'interests_done')]);
    return Markup.inlineKeyboard(keyboard);
}

function createChatKeyboard() {
    return Markup.inlineKeyboard([
        [Markup.button.callback('â­ï¸ Next', 'next_chat')],
        [Markup.button.callback('â¹ï¸ Stop', 'stop_chat'), Markup.button.callback('ğŸš¨ Report', 'report_user')]
    ]);
}

// Scenes setup
const stage = new Scenes.Stage([profileSetupScene]);

// Middleware
bot.use(session());
bot.use(stage.middleware());

// Update user activity middleware
bot.use(async (ctx, next) => {
    if (ctx.from) {
        await DatabaseOperations.updateUserActivity(ctx.from.id);
    }
    return next();
});

// Commands
bot.command('start', async (ctx) => {
    try {
        const user = await DatabaseOperations.getUser(ctx.from.id);
        
        if (user && !user.isBanned) {
            await ctx.reply(
                `ğŸ‘‹ Welcome back, ${ctx.from.first_name}!\n\n` +
                'ğŸ” Use /find to start chatting\n' +
                'ğŸ‘¤ Use /profile to update your information\n' +
                'â“ Use /help for available commands',
                createChatKeyboard()
            );
        } else if (user && user.isBanned) {
            await ctx.reply('âŒ Your account has been banned. Contact support for more information.');
        } else {
            await ctx.scene.enter('PROFILE_SETUP');
        }
    } catch (error) {
        console.error('Start command error:', error);
        await ctx.reply('âŒ Something went wrong. Please try again.');
    }
});

bot.command('profile', async (ctx) => {
    try {
        const user = await DatabaseOperations.getUser(ctx.from.id);
        
        if (!user) {
            await ctx.reply('âŒ No profile found. Use /start to create one.');
            return;
        }
        
        const profileText = 
            `ğŸ‘¤ **Your Profile**\n\n` +
            `ğŸ‚ Age: ${user.age}\n` +
            `ğŸ‘¤ Gender: ${user.gender}\n` +
            `ğŸ“ Education: ${user.education}\n` +
            `ğŸŒ Language: ${user.language}\n` +
            `ğŸ’• Looking for: ${user.preferredGender}\n` +
            `ğŸ¯ Interests: ${user.interests.join(', ')}\n\n` +
            `ğŸ“… Joined: ${moment(user.createdAt).format('MMM DD, YYYY')}`;
        
        await ctx.reply(profileText, {
            parse_mode: 'Markdown',
            ...Markup.inlineKeyboard([
                [Markup.button.callback('âœï¸ Edit Profile', 'edit_profile')],
                [Markup.button.callback('ğŸ” Find Match', 'find_match')]
            ])
        });
    } catch (error) {
        console.error('Profile command error:', error);
        await ctx.reply('âŒ Error retrieving profile.');
    }
});

bot.command('find', async (ctx) => {
    try {
        const user = await DatabaseOperations.getUser(ctx.from.id);
        
        if (!user) {
            await ctx.reply('âŒ Please create a profile first using /start');
            return;
        }
        
        if (user.isBanned) {
            await ctx.reply('âŒ Your account has been banned.');
            return;
        }
        
        // Check if already in a chat
        const existingMatch = await DatabaseOperations.getActiveMatch(ctx.from.id);
        if (existingMatch) {
            await ctx.reply('ğŸ’¬ You\'re already in a chat! Use /next to find someone new or /stop to end the current chat.');
            return;
        }

        // Add user to queue first (so they can be found by others)
        await DatabaseOperations.addToQueue(ctx.from.id);
        
        // Use the new waiting mechanism to find a match
        const match = await MatchingService.findMatchWithWait(user, ctx, 30);
        
        if (match) {
            // Remove both users from queue
            await DatabaseOperations.removeFromQueue(ctx.from.id);
            await DatabaseOperations.removeFromQueue(match.userId);
            
            // Create match
            const matchId = await DatabaseOperations.createMatch(ctx.from.id, match.userId);
            
            // Calculate compatibility info for display
            const sharedInterests = user.interests.filter(interest => 
                match.interests.includes(interest)
            );
            const compatibilityScore = MatchingService.calculateCompatibilityScore(user, match);
            
            // Notify both users with enhanced match information
            const matchNotification = 
                'ğŸ‰ **Perfect Match Found!**\n\n' +
                `âœ¨ Compatibility Score: ${compatibilityScore} points\n` +
                `ğŸ¤ Shared Interests: ${sharedInterests.length > 0 ? sharedInterests.slice(0, 3).join(', ') : 'Exploring together'}\n` +
                `ğŸŒ Language: ${user.language === match.language ? 'Same language' : 'Different languages'}\n\n` +
                'ğŸ’¬ Start chatting below. Your identity remains anonymous.\n' +
                'âš ï¸ Be respectful and follow community guidelines.';
            
            await ctx.reply(matchNotification, {
                parse_mode: 'Markdown',
                ...createChatKeyboard()
            });
            
            // Notify the matched user
            try {
                const partnerNotification = 
                    'ğŸ‰ **Perfect Match Found!**\n\n' +
                    `âœ¨ Compatibility Score: ${compatibilityScore} points\n` +
                    `ğŸ¤ Shared Interests: ${sharedInterests.length > 0 ? sharedInterests.slice(0, 3).join(', ') : 'Exploring together'}\n` +
                    `ğŸŒ Language: ${user.language === match.language ? 'Same language' : 'Different languages'}\n\n` +
                    'ğŸ’¬ Start chatting below. Your identity remains anonymous.\n' +
                    'âš ï¸ Be respectful and follow community guidelines.';

                await bot.telegram.sendMessage(match.userId, partnerNotification, {
                    parse_mode: 'Markdown',
                    ...createChatKeyboard()
                });
            } catch (error) {
                console.error('Error notifying matched user:', error);
            }
        } else {
            // User remains in queue, send helpful message
            await ctx.reply(
                'ğŸ“Š **Queue Status Update**\n\n' +
                'ğŸ‘¥ You\'re in the waiting queue\n' +
                'ğŸ”” We\'ll notify you instantly when a match arrives\n' +
                'â° Average wait time: 2-5 minutes\n\n' +
                'ğŸ’¡ **Tips while waiting:**\n' +
                'â€¢ Update your interests in /profile\n' +
                'â€¢ Share with friends to grow the community\n' +
                'â€¢ Try again in a few minutes for more users\n\n' +
                'ğŸ¯ Use /find again anytime to restart the search!',
                { 
                    parse_mode: 'Markdown',
                    ...Markup.inlineKeyboard([
                        [Markup.button.callback('ğŸ”„ Search Again', 'search_again')],
                        [Markup.button.callback('ğŸ‘¤ Edit Profile', 'edit_profile')]
                    ])
                }
            );
        }
    } catch (error) {
        console.error('Find command error:', error);
        await ctx.reply('âŒ Error finding matches. Please try again.');
    }
});

bot.command('next', async (ctx) => {
    try {
        const activeMatch = await DatabaseOperations.getActiveMatch(ctx.from.id);
        
        if (!activeMatch) {
            await ctx.reply('âŒ You\'re not in a chat right now. Use /find to start one.');
            return;
        }
        
        // Get partner ID
        const partnerId = activeMatch.participants.find(id => id !== ctx.from.id);
        
        // End current match
        await DatabaseOperations.endMatch(activeMatch.id);
        
        // Notify partner
        if (partnerId) {
            try {
                await bot.telegram.sendMessage(partnerId, 
                    'ğŸ‘‹ Your chat partner left to find someone new.\n\nğŸ” Use /find to start a new chat!',
                    createChatKeyboard()
                );
            } catch (error) {
                console.error('Error notifying partner:', error);
            }
        }
        
        // Get user profile for new search
        const user = await DatabaseOperations.getUser(ctx.from.id);
        if (!user) {
            await ctx.reply('âŒ Profile not found. Please use /start to create one.');
            return;
        }

        // Add to queue and start new search with waiting
        await DatabaseOperations.addToQueue(ctx.from.id);
        
        await ctx.reply('ğŸ”„ **Finding you someone new...**\n\nâ³ Searching for a better match...');
        
        const newMatch = await MatchingService.findMatchWithWait(user, ctx, 25);
        
        if (newMatch) {
            // Remove both users from queue
            await DatabaseOperations.removeFromQueue(ctx.from.id);
            await DatabaseOperations.removeFromQueue(newMatch.userId);
            
            // Create new match
            const matchId = await DatabaseOperations.createMatch(ctx.from.id, newMatch.userId);
            
            // Calculate compatibility info
            const sharedInterests = user.interests.filter(interest => 
                newMatch.interests.includes(interest)
            );
            const compatibilityScore = MatchingService.calculateCompatibilityScore(user, newMatch);
            
            // Notify both users
            const matchNotification = 
                'ğŸ‰ **New Match Found!**\n\n' +
                `âœ¨ Compatibility Score: ${compatibilityScore} points\n` +
                `ğŸ¤ Shared Interests: ${sharedInterests.length > 0 ? sharedInterests.slice(0, 3).join(', ') : 'Exploring together'}\n` +
                `ğŸŒ Language: ${user.language === newMatch.language ? 'Same language' : 'Different languages'}\n\n` +
                'ğŸ’¬ Start your new conversation below!\n' +
                'âš ï¸ Be respectful and follow community guidelines.';
            
            await ctx.reply(matchNotification, {
                parse_mode: 'Markdown',
                ...createChatKeyboard()
            });
            
            // Notify the new matched user
            try {
                await bot.telegram.sendMessage(newMatch.userId, matchNotification, {
                    parse_mode: 'Markdown',
                    ...createChatKeyboard()
                });
            } catch (error) {
                console.error('Error notifying new matched user:', error);
            }
        } else {
            // No match found, provide helpful options
            await ctx.reply(
                'ğŸ“Š **Search Complete**\n\n' +
                'ğŸ‘¥ You\'re back in the waiting queue\n' +
                'ğŸ”” We\'ll notify you when someone compatible joins\n\n' +
                'ğŸ’¡ **While waiting, you can:**\n' +
                'â€¢ Try searching again in a few minutes\n' +
                'â€¢ Update your profile to attract more matches\n' +
                'â€¢ Invite friends to join the platform',
                { 
                    parse_mode: 'Markdown',
                    ...Markup.inlineKeyboard([
                        [Markup.button.callback('ğŸ”„ Search Again', 'search_again')],
                        [Markup.button.callback('ğŸ‘¤ Edit Profile', 'edit_profile')]
                    ])
                }
            );
        }
        
    } catch (error) {
        console.error('Next command error:', error);
        await ctx.reply('âŒ Error finding new match. Please try again.');
    }
});

bot.command('stop', async (ctx) => {
    try {
        const activeMatch = await DatabaseOperations.getActiveMatch(ctx.from.id);
        
        if (!activeMatch) {
            await ctx.reply('âŒ You\'re not in a chat right now.');
            return;
        }
        
        // Get partner ID
        const partnerId = activeMatch.participants.find(id => id !== ctx.from.id);
        
        // End match
        await DatabaseOperations.endMatch(activeMatch.id);
        
        // Remove from queue if there
        await DatabaseOperations.removeFromQueue(ctx.from.id);
        
        // Notify both users
        await ctx.reply('â¹ï¸ Chat ended. Use /find to start a new conversation!', createChatKeyboard());
        
        if (partnerId) {
            try {
                await bot.telegram.sendMessage(partnerId, 
                    'â¹ï¸ Your chat partner ended the conversation.\n\nğŸ” Use /find to start a new chat!',
                    createChatKeyboard()
                );
            } catch (error) {
                console.error('Error notifying partner:', error);
            }
        }
    } catch (error) {
        console.error('Stop command error:', error);
        await ctx.reply('âŒ Error ending chat. Please try again.');
    }
});

bot.command('report', async (ctx) => {
    try {
        const activeMatch = await DatabaseOperations.getActiveMatch(ctx.from.id);
        
        if (!activeMatch) {
            await ctx.reply('âŒ You\'re not in a chat right now.');
            return;
        }
        
        const partnerId = activeMatch.participants.find(id => id !== ctx.from.id);
        const reportText = ctx.message.text.split(' ').slice(1).join(' ') || 'No reason provided';
        
        // Send report to admin
        if (ADMIN_CHAT_ID) {
            const reportMessage = 
                `ğŸš¨ **USER REPORT**\n\n` +
                `ğŸ‘¤ Reporter: ${ctx.from.id} (${ctx.from.username || ctx.from.first_name})\n` +
                `ğŸ¯ Reported User: ${partnerId}\n` +
                `ğŸ“ Reason: ${reportText}\n` +
                `ğŸ• Time: ${moment().format('YYYY-MM-DD HH:mm:ss')}\n` +
                `ğŸ’¬ Match ID: ${activeMatch.id}`;
            
            await bot.telegram.sendMessage(ADMIN_CHAT_ID, reportMessage, {
                parse_mode: 'Markdown'
            });
        }
        
        await ctx.reply('âœ… Report submitted. Thank you for helping keep our community safe.');
        
        // Optionally end the chat
        await DatabaseOperations.endMatch(activeMatch.id);
        await ctx.reply('â¹ï¸ Chat ended for your safety. Use /find to start a new conversation.');
        
    } catch (error) {
        console.error('Report command error:', error);
        await ctx.reply('âŒ Error submitting report. Please try again.');
    }
});

bot.command('help', async (ctx) => {
    const helpText = 
        `ğŸ¤– **Anonymous Chat Bot Help**\n\n` +
        `**Commands:**\n` +
        `ğŸ /start - Create or reset your profile\n` +
        `ğŸ‘¤ /profile - View and update your profile\n` +
        `ğŸ” /find - Find someone to chat with\n` +
        `â­ï¸ /next - Leave current chat and find new person\n` +
        `â¹ï¸ /stop - End current chat\n` +
        `ğŸš¨ /report - Report inappropriate behavior\n` +
        `â“ /help - Show this help message\n\n` +
        `**How it works:**\n` +
        `1ï¸âƒ£ Create your profile with interests and preferences\n` +
        `2ï¸âƒ£ Use /find to get matched with compatible people\n` +
        `3ï¸âƒ£ Chat anonymously with your match\n` +
        `4ï¸âƒ£ Use /next to find someone new or /stop to end\n\n` +
        `**Matching factors:**\n` +
        `â€¢ Shared interests\n` +
        `â€¢ Age compatibility\n` +
        `â€¢ Gender preferences\n` +
        `â€¢ Language\n\n` +
        `Stay safe and be respectful! ğŸ’™`;
    
    await ctx.reply(helpText, { parse_mode: 'Markdown' });
});

// Handle inline button callbacks
bot.action('find_match', async (ctx) => {
    await ctx.answerCbQuery();
    // Simulate /find command
    ctx.message = { text: '/find', from: ctx.from, chat: ctx.chat };
    return bot.handleUpdate(ctx);
});

bot.action('search_again', async (ctx) => {
    await ctx.answerCbQuery('ğŸ”„ Starting new search...');
    
    try {
        const user = await DatabaseOperations.getUser(ctx.from.id);
        if (!user) {
            await ctx.reply('âŒ Profile not found. Please use /start to create one.');
            return;
        }

        // Check if already in a chat
        const existingMatch = await DatabaseOperations.getActiveMatch(ctx.from.id);
        if (existingMatch) {
            await ctx.reply('ğŸ’¬ You\'re already in a chat! Use /next to find someone new or /stop to end the current chat.');
            return;
        }

        // Remove any existing queue entry and add fresh one
        await DatabaseOperations.removeFromQueue(ctx.from.id);
        await DatabaseOperations.addToQueue(ctx.from.id);
        
        // Start new search with waiting mechanism
        const match = await MatchingService.findMatchWithWait(user, ctx, 30);
        
        if (match) {
            // Remove both users from queue
            await DatabaseOperations.removeFromQueue(ctx.from.id);
            await DatabaseOperations.removeFromQueue(match.userId);
            
            // Create match
            const matchId = await DatabaseOperations.createMatch(ctx.from.id, match.userId);
            
            // Calculate compatibility info
            const sharedInterests = user.interests.filter(interest => 
                match.interests.includes(interest)
            );
            const compatibilityScore = MatchingService.calculateCompatibilityScore(user, match);
            
            // Notify both users with enhanced match information
            const matchNotification = 
                'ğŸ‰ **Match Found!**\n\n' +
                `âœ¨ Compatibility Score: ${compatibilityScore} points\n` +
                `ğŸ¤ Shared Interests: ${sharedInterests.length > 0 ? sharedInterests.slice(0, 3).join(', ') : 'Exploring together'}\n` +
                `ğŸŒ Language: ${user.language === match.language ? 'Same language' : 'Different languages'}\n\n` +
                'ğŸ’¬ Start chatting below. Your identity remains anonymous.\n' +
                'âš ï¸ Be respectful and follow community guidelines.';
            
            await ctx.reply(matchNotification, {
                parse_mode: 'Markdown',
                ...createChatKeyboard()
            });
            
            // Notify the matched user
            try {
                await bot.telegram.sendMessage(match.userId, matchNotification, {
                    parse_mode: 'Markdown',
                    ...createChatKeyboard()
                });
            } catch (error) {
                console.error('Error notifying matched user:', error);
            }
        } else {
            await ctx.reply(
                'ğŸ” **Search Complete**\n\n' +
                'ğŸ‘¥ Still in the waiting queue\n' +
                'ğŸ”” We\'ll notify you when someone joins\n\n' +
                'ğŸ’¡ Try again in a few minutes for new users!',
                { 
                    parse_mode: 'Markdown',
                    ...Markup.inlineKeyboard([
                        [Markup.button.callback('ğŸ”„ Search Again', 'search_again')],
                        [Markup.button.callback('ğŸ‘¤ Edit Profile', 'edit_profile')]
                    ])
                }
            );
        }
    } catch (error) {
        console.error('Search again error:', error);
        await ctx.reply('âŒ Error during search. Please try /find command.');
    }
});

bot.action('next_chat', async (ctx) => {
    await ctx.answerCbQuery();
    // Simulate /next command
    ctx.message = { text: '/next', from: ctx.from, chat: ctx.chat };
    return bot.handleUpdate(ctx);
});

bot.action('stop_chat', async (ctx) => {
    await ctx.answerCbQuery();
    // Simulate /stop command
    ctx.message = { text: '/stop', from: ctx.from, chat: ctx.chat };
    return bot.handleUpdate(ctx);
});

bot.action('report_user', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('ğŸš¨ Please type your report reason after /report command\n\nExample: /report This user is being inappropriate');
});

bot.action('edit_profile', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('âœï¸ To edit your profile, please create a new one using /start\n\n(Profile editing feature coming soon!)');
});

// Message forwarding for active chats
bot.on(['text', 'photo', 'voice', 'sticker', 'video', 'document'], async (ctx) => {
    try {
        // Skip commands
        if (ctx.message.text && ctx.message.text.startsWith('/')) return;
        
        const activeMatch = await DatabaseOperations.getActiveMatch(ctx.from.id);
        if (!activeMatch) return;
        
        const partnerId = activeMatch.participants.find(id => id !== ctx.from.id);
        if (!partnerId) return;
        
        // Filter inappropriate content for text messages
        if (ctx.message.text) {
            const cleanText = filter.clean(ctx.message.text);
            if (cleanText !== ctx.message.text) {
                await ctx.reply('âš ï¸ Message contains inappropriate content and was not sent.');
                return;
            }
        }
        
        // Forward message to partner
        try {
            if (ctx.message.text) {
                await bot.telegram.sendMessage(partnerId, `ğŸ’¬ ${ctx.message.text}`);
            } else if (ctx.message.photo) {
                await bot.telegram.sendPhoto(partnerId, ctx.message.photo[ctx.message.photo.length - 1].file_id, {
                    caption: ctx.message.caption ? `ğŸ’¬ ${ctx.message.caption}` : 'ğŸ“· Photo'
                });
            } else if (ctx.message.voice) {
                await bot.telegram.sendVoice(partnerId, ctx.message.voice.file_id, {
                    caption: 'ğŸ¤ Voice message'
                });
            } else if (ctx.message.sticker) {
                await bot.telegram.sendSticker(partnerId, ctx.message.sticker.file_id);
            } else if (ctx.message.video) {
                await bot.telegram.sendVideo(partnerId, ctx.message.video.file_id, {
                    caption: ctx.message.caption ? `ğŸ’¬ ${ctx.message.caption}` : 'ğŸ¥ Video'
                });
            } else if (ctx.message.document) {
                await bot.telegram.sendDocument(partnerId, ctx.message.document.file_id, {
                    caption: ctx.message.caption ? `ğŸ’¬ ${ctx.message.caption}` : 'ğŸ“„ Document'
                });
            }
        } catch (error) {
            console.error('Error forwarding message:', error);
            await ctx.reply('âŒ Message could not be delivered. Your partner may have left the chat.');
        }
    } catch (error) {
        console.error('Message handling error:', error);
    }
});

// Error handling
bot.catch((err, ctx) => {
    console.error('Bot error:', err);
    if (ctx) {
        ctx.reply('âŒ An unexpected error occurred. Please try again.').catch(console.error);
    }
});

// Graceful shutdown
process.once('